---
layout: post
title: 자바스터디_01
comments : true
---

# 프로그래밍 언어란?
> 컴퓨터가 이해할 수 있는 언어는 우리가 일상생활에서 사용하는 언어와는 너무나도 다른 기계어입니다.
> 
> 기계어는 0과 1로 이루어진 이진 코드이기 때문에 사람이 이해하기에는 매우 어렵습니다.
> 
> 반면 사람이 사용하는 언어는 컴퓨터 입장에서 보면 이해할 수 없는 문자 집합입니다.
> 
> 그렇기에 사람과 컴퓨터가 대화하기 위해서는 사람의 언어와 기계어의 다리 역할을 하는 프로그래밍 언어가 필요합니다.
> 

# 저급언어와 고급언어??
> 프로그래밍 언어는 고급 언어와 저급 언어로 구분됩니다.
> 
> 고급언어란 컴퓨터와 대화할 수 있도록 만든 언어 중에서 사람이 쉽게 이해할 수 있는 언어를 말합니다.
> 
> 고급언어로 작성된 소스는 컴퓨터가 바로 이해할 수 없기 때문에 컴파일(Compile) 과정을 통해서 컴퓨터가 이해할 수 있는
> 0과 1로 이루어진 기계어로 변환한 후 컴퓨터가 사용하게 됩니다.
> 
> 반대로 저급 언어란 기계어에 가까운 언어를 말하는데.. 대표적으로 어셈블리어가 저급 언어에 속합니다.
> 
> 저급 언어는 사람이 쉽게 이해할 수 없기 때문에 배우기가 매우 어렵고 까다롭습니다..
> 
> C나 JAVA는 모두 고급언어에 속합니다.
> 이 언어들로 작성된 내용을 소스(Source) 라고 부르고, 이 소스는 컴파일러(Compile) 라는 소프트웨어에 의해 기계어로 변환된 후 컴퓨터에서 실행할 수
> 있게 됩니다.
>
>우리가 흔히 말하는 프로그램(Program) 이란 컴퓨터에서 특정 목적을 수행하기 위해 프로그래밍 언어로 작성된 소스를 기계어로 번역한 것을 말합니다.


# 자바란?
> 1995년도에 처음 썬 마이크로시스템즈에서 자바언어를 발표한 후, 지금까지 자바는 성공한 프로그래밍 언어로써 전세계적으로 다양한 분야에서 사용되고 있습니다.
>
> 1995년부터 1999년까지는 위도우 프로그램 개발이 주류였기 때문에 C++언어에 비해 자바는 아주 열세였습니다.
>
> 메모리 및 CPU를 지나치게 많이 사용하기 때문에 윈도우 프로그래밍 언어로는 부적합하다는 문제점이 있었습니다.
>
> 하지만 1999년도부터 인터넷이 활성화되면서 웹 어플리케이션 구축용 언어로 자바가 급부상했습니다.
>
> 그 이유는 기업체 및 공공기관의 다양한 서버 운영체제에서 단 한 번의 작성으로 모든 곳에서 실행 가능한 언어는 자바뿐이었기 때문입니다.
>
> 초기 자바는 가전 제품에 탑재할 IOT 프로그래밍 언어로 개발되었지만, 지금은 스마트폰을 비롯해서 각종 장비와 데스크탑에서 실행되는 
> 애플리케이션, 그리고 금융, 공공, 대기업 등의 엔터프라이즈 기업환경에서 실행되는 서버 애플리케이션을 개발하는 중추적인 언어로 자리매김중입니다.
> 

# 자바의 특징?!
* 이식성이 높다.
> 이 말은 즉슨 서로 다른 실행환경(OS)를 가진 시스템 간의 프로그램을 옮겨 실행할 수 있는 것을 말합니다.
> 윈도우에서 돌아가는 자바 애플리케이션을 유닉스, 리눅스나 MAC OS 에서도 실행가능하다면 이식성이 높은것이고 실행할 수 없다면 이식성이
> 낮다고 볼 수 있습니다.

* 객체 지향 언어이다.
> 프로그램을 개발하는 기법으로 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립 및 연결해서 전체 프로그램을 완성하는 기법을
> 객체 지향 프로그램(OOP) 라고 합니다. 
>
> 자바는 100% 객체 지향 언어입니다. 객체를 만들기 위해 설계도인 클래스를 작성해야 하고, 객체와 객체를 연결하여 목적에 맞는 프로그램을 만들어 냅니다.
>
> 자바는 아무리 작은 프로그램이라도 객체를 만들어 사욥합니다. 
>
> 처음부터 객체를 고려하여 설계되었기 때문에 객체 지향 언어가 가져야 할 캡슐화, 상속, 다형성 기능을 완벽하게 지원하고 있습니다.

* 함수적 스타일 코딩을 지원합니다.
> 자바는 객체 지향 프로그래밍이 소프트웨어 개발의 주요 패러다임이었던 1990년대에 디자인 되었습니다.
>
> 객체 지향 프로그래밍이 나오기 이전부터 LISP 또는 Scheme 와 같은 함수적 프로그래밍 언어들이 있었는데 
> 학계를 제외하고는 현업에서는 큰 호응을 얻지 못하였습니다.
>
> 최근들어 함수적 프로그래밍이 다시 부각되고 있는데, 대용량 데이터의 병렬처리, 그리고 이벤트 지향 프로그래밍을 위해 적합하기 때문입니다.
>
> 자바는 함수적 프로그래밍을 위해 람다식을 1.8 버젼부터 지원하고 있는데 람다식을 사용하면 컬렉션의 요소를 필터링, 매핑, 집계 처리하는데
> 매우 쉬워지고, 코드가 매우 간경해집니다.

* 메모리를 자동으로 관리해줍니다.
> C++은 메모리에 생성된 객체를 제거하기 위해 개발자가 직접 코드를 작성해야 합니다.
>
> 만약 이 작업을 성실하게 해주지 않으면, 프로그램은 불완전해지고 갑자기 다운되는 현상을 겪게됩니다.
> 
> 자바는 개발자가 직접 메모리에 접근할 수 없도록 설계되었으며, 메모리는 자바가 직접 관리합니다.
>
> 객체 생성 시 자동적으로 메모리 영역을 찾아서 할당해주고, 사용이 끝나면 쓰레기 수집기(Garbage Collector)를 실행시켜
> 자동적으로 사용하지 않는 객체를 제거시켜줍니다.
>
> 따라서 개발자는 메모리관리의 수고스러움을 덜수있고, 핵심 기능 코드 작성에 집중할 수 있습니다.


* 멀티 스레드를 쉽게 구현할 수 있습니다.
> 하나의 프로그램이 동시에 여러 가지 작업을 처리해야 할 경우와 대용량 작업을 빨리 처리하기 위해 서브 작업으로 분리해서 병렬 처리하려면
> 멀티 스레드 프로그래밍이 필요합니다.
>
> 프로그램이 실행되는 운영체제에 따라서 멀티 스레드를 구현하는 방법이 다르지만, 자바는 스레드 생성 및 제어와 관련된 라이브러리 API를
> 제공하고 있기 때문에 실행되는 운영체제에 상관없이 멀티 스레드를 쉽게 구현할 수 있습니다.
>

* 동적 로딩을 지원합니다.
> 자바 어플리케이션은 여러 개의 객체가 서로 연결되어 실행되는데, 이 객체들은 클래스로부터 생성됩니다.
>
> 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 객체가 필요한 시점에 클래스를 동적로딩해서 객체를 생성합니다.
>
> 또한 개발 완료 후 유지보수(수정)이 발생하더라도 해당 클래스만 수정하면 되므로 전체 애플리케이션을 다시 컴파일할 필요가 없습니다.
>
> 따라서 유지보수를 쉽고 빠르게 진행할 수 있습니다.

* 막강한 오픈소스 라이브러리가 풍부합니다.
> 자바는 오픈소스 언어이기 때문에 자바 프로그램에서 사용하는 라이브러리 또한 오픈소스가 넘쳐납니다.
>
> 고급 기능을 구현하는 코드를 직접 작성할 경우, 시간과 노력이 필요하고, 실행 안전성을 보장할 수 없지만, 검증된 오픈소스 라이브러리를 사용하면
> 개발 기간을 단축하면서 안전성이 높은 애플리케이션을 쉽게 개발할 수 있습니다.
>
> 많은 회사들이 자바를 선택하는 이유 중 하나가 막강하고 풍부한 자바 오픈소스 라이브러리가 있기 때문입니다.


## 여기서 잠깐!!

> * JAVA SE(Standard Edition) = 기본 에디션
>> JAVA SE는 자바 프로그램들이 공통적으로 사용하는 자바 가상 기계(JVM)를 비롯하여 자바 프로그램 개발에 필수적인 도구와 라이브러리 API를 정의합니다.
>>
>> 클라이언트와 서버 프로그램에 상관없이 자바 프로그램을 개발하고 실행하기 위해서는 반드시 JAVA SE 구현체인 자바 개발 키트(JDK)를 설치해야합니다.
> * JAVA EE(Enterprise Edition) = 서버용 애플리케이션 개발 에디션
>> JAVA EE는 분산 환경(네트워크, 인터넷) 에서 서버용 애플리케이션을 개발하기 위한 도구 및 라이브러리 API를 정의합니다.
>
>> 서버용 애플리케이션으로는 Servlet/JSP를 이용한 웹 애플리케이션, 분산 처리 컴포넌트인 EJB(Enterprise Java Bean) 그리고 XML 웹 서비스 등이 있습니다.
>>




# JVM 이란
##### Java Virtual Machine 의 줄임말입니다.
운영체제는 자바 프로그램을 바로 실행할 수 없는데, 그 이유는 자바 프로그램은 완전한 기계어가 아닌, 중간 단계의 바이트 코드이기 때문에

이것을 해석하고 실행할 수 있는 가상의 운영체제가 필요합니다. 이것이 바로 자바가상머신(JVM : JAVA Virtual Machine) 입니다.

JVM은 실 운영체제를 대신해서 자바 프로그램을 실행하는 가상의 운영체제 역할을 합니다.

JVM이 없다면 우리는 각각의 OS에 맞게 새롭게 자바 프로그램을 별도로 만들어 주어야 했을지도 모릅니다.

이런 자바 프로그램을 별도로 개발하는 것 보다야 운영체제와 자바 프로그램을 중계하는 JVM 을 중간에 두어서 자바 프로그램이 여러 운영체제에서

동일한 실행 결과가 나오도록 설계한 것입니다.

따라서 개발자는 운영체제와 상관없이 자바 프로그램을 개발할 수 있습니다.

JVM은 그러한 자바의 바이트 코드를 OS에 맞게 해석해주는 역할을 합니다. 

> 참고로 자바바이트 코드는 모든 JVM에서 동일한 실행 결과를 보장하지만, JVM은 운영체제 종속적이라, 자바 프로그램을 운영체제가 이해하는 기계어로 번역해서
> 실행해야 하므로 JVM은 운영체제에 맞게 설치되어야 합니다.

자바 컴파일러는 java파일을 class라는 파일식별자를 가진 바이트코드 파일로 변환을 해주고 그러한 바이트코드를 각 OS에 상관없이 모든 OS가 이해할 수 있도록 해석해주는 것이 JVM이라 할수 있습니다.

JVM은 크게 Class Loader, Runtime Data Areas, Excution Engine, Garbage Collector 4가지로 구성되어 있으며 구조는 밑의 이미지와 같습니다.

![jvm_intro](/assets/java_study/jvm_intro.png)

이미지 출저 : https://medium.com/@lazysoul/jvm-%EC%9D%B4%EB%9E%80-c142b01571f2


###Class Loader
RunTime 시점에 클래스를 로딩하게 해주며 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리에 로드하게 됩니다.

즉슨 Test.java 와 같은 자바 소스코드 파일을 자바컴파일러(javac)가 컴파일 하면 .class 확장자를 가진 바이트코드가 생성됩니다.

이렇게 생성된 .class 파일들을 가져와 JVM이 운영체제로 부터 할당받은 메모리 영역인 Runtime Data Area 로 적재(로딩)하는 역할을 하는 것이

클래스 로더의 핵심 역할입니다.

###Runtime Data Areas
JVM의 메모리 영역으로써 자바 프로그램이 실행될 때 사용되는 데이터들을 적재할 때 사용하는 영역들입니다.

JVM이 프로그램을 수행하기 위해 OS로 부터 별도로 할당 받은 메모리 공간을 말하며, Runtime Data Areas는 크게 5가지 영역으로 나눌 수 있습니다.



* PC Register
> PC Registers는 Thread가 생성될 때 마다 생기는 공간으로 Thread가 어떠한 명령을 실행하게 될지에 대한 부분을 기록을 합니다..
> 
> JVM은 Stacks-Base 방식으로 작동 하는데, JVM은 CPU에 직접 Instruction을 수행하지 않고, Stack에서 Operand를 뽑아내 이를 별도의 메모리 공간에 저장하는 방식을 취하는데, 
> 
> 이러한 메모리 공간을 PC Registers라고 합니다.
> 
> Thread(쓰레드)가 생성될 때마다 생성되는 영역으로 Program Counter 즉, 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역입니다. (*CPU의 레지스터와 다름)
>
> 이것을 이용해서 쓰레드를 돌아가면서 수행할 수 있게 합니다.


* Java Virtual Machine Stack
> 프로그램 실행 중 클래스가 사용되면 JVM은 해당 클래스 파일을 읽어서 분석하여 클래스의 인스턴스 변수, 메소드 코드 등을 Method Area에 저장한다. 이 때 클래스 변수도 이 영역에 함께 생성됩니다..
>
> 프로그램이 실행되면 모든 코드가 저장되어 있는 상태가 아닙니다.
> 
> new 키워드를 통해 객체가 동적으로 생성되기 이전에는 텍스트 일뿐이죠.
>
> 객체 생성 후에 메소드를 실행하게 되면 해당 클래스 코드에 대한 정보를 Method Area에 저장 하게 됩니다.
> 
> 지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역입니다..
>
> int a = 10; 이라는 소스를 작성했다면 정수값이 할당될 수 있는 메모리공간을 a라고 잡아두고 그 메모리 영역에 값이 10이 들어갑니.
> 
> 즉, 스택 메모리에 한 공간에 이름을 a라고 붙여주고 값이 10인 메모리 공간을 만듭니다.
>
> 클래스 Person p = new Person(); 이라는 소스를 작성했다면 Person p는 스택 영역에 생성되고 new로 생성된 Person 클래스의 인스턴스는 힙 영역에 생성됩니.
>
> 그리고 스택영역에 생성된 p의 값으로 힙 영역의 주소값을 가지고 있습니다. 
> 다
> 즉, 스택 영역에 생성된 p가 힙 영역에 생성된 객체를 가리키고(참조하고) 있는 것입니다.
>
> 메소드를 호출할 때마다 개별적으로 스택이 생성됩니.



* Native Method Stack
> 자바 이외의 이기종 언어에서 제공되는 Method의 정보가 저장 되는 공간, JNI를 통해 표준에 가까운 방식으로 구현이 가능합니다.
>
> 보통 C/C++등의 코드를 수행하기 위한 스택입니다. (JNI)
> 
> 쓰레드가 생성되었을 때 기준으로 메소드 영역과 힙 영역을 모든 쓰레드가 공유하고,
> 스택 영역과 PC 레지스터, Native method stack은 각각의 쓰레드마다 생성되고 공유되지 않습니다.


* Method Area (메소드 영역)
> 모든 쓰레드가 공유하는 메모리 영역입니다. 클래스, 인터페이스, 메소드, 필드, static 변수 등의 바이트 코드를 보관 합니다.
> 
> 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보와 같은 필드 정보와 메소드의 이름, 리턴 타입, 파라미, 접근 제어자 정보같은 메소드 정보,
> Type정보 (인스턴스인지 클래스인지), Constant pool(상수 풀 : 문자 상수, 타입 필드, 객체 참조가 저장), static 변수, final class 변수등이 생성되는 영역입니다.



* Heap
> new 키워드로 생성된 객체와 배열이 저장되어지는 영역입니다.
> 
> 프로그램 상에서 런타임시 동적으로 할당되어 사용되어지는 영역입니다. 
> 
> 클래스를 이용해 인스턴스를 생성하면 생성된 인스턴스는 heap에 저장됩니다.
>
> 메소드 영역에 로드되어진 클래스만 생성가능하고 가비지 컬렉터가 참조되지 않는 메모리를 확인하고 제거하는 영역입니다.

* Execution Engine
> Load된 Class의 ByteCode를 실행하는 Runtime Module이 바로 Execution Engine입니다. 
> 
> Class Loader를 통해 JVM 내의 Runtime Data Areas 에 배치된 바이트 코드는 Executin Engine에 의해 실행되며, 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행합니다.

출처: https://jeong-pro.tistory.com/148 [기본기를 쌓는 정아마추어 코딩블로그]

# 컴파일 하는 방법
##### 우선 자바를 설치한 후 환경변수 설정까지 등록해줍니다.
![java_compile_01](/assets/java_study/java_compile_01.png)

우선 간단한 소스코드를 nano편집기로 작성후

![java_compile_02](/assets/java_study/java_compile_02.png)에

javac (자바 컴파일러)로 실행시킵니다.

![java_compile_03](/assets/java_study/java_compile_03.png)

그리고 난 후에는 컴파일 된 자바의 바이트코드가 나오게됩니다.



# 실행하는 방법

![java_execute_01](/assets/java_study/java_execute_01.png)

그리고 컴파일 되어진 바이트코드를 java 명령어를 통해 간단하게 실행시킬수 있습니다.


# 바이트코드란 무엇인가!

자바 바이트 코드(Java bytecode)
자바 바이트 코드(Java bytecode)란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미합니다.

자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불리고 있습니다.

이러한 자바 바이트 코드의 확장자는 .class입니다.

자바 바이트 코드는 자바 가상 머신만 설치되어 있으면, 어떤 운영체제에서라도 실행될 수 있습니다.


# JIT 컴파일러란 무엇인가?
#### JIT 란 Just In Time 이라는 뜻을 가지고 있습니다. 실시간 컴파일이라 일단 이해하시면 될 듯합니다.


JIT 컴파일러는 같은 코드를 매번 해석하지 않고 실행할 때 컴파일을 하면서 해당 코드를 캐싱해버립니다. 

이후엔, 바뀐 부분만 컴파일 하고 나머지는 캐싱저장되어진 코드를 사용합니다.. 그리하 인터프리터의 속도를 개선할 수 있습니다.

![JIT_Compile](/assets/java_study/JIT_Compile.png)

출저 : https://medium.com/@ahn428/java-jit-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-c7d068e29f45

# JVM 구성요소


![JVM_Arch](/assets/java_study/JVM_Arch.jpeg)

자료 및 이미지 출저 : https://sjh836.tistory.com/64

#### 클래스 로더 

.java 파일을 javac로 컴파일하면 자바 바이트코드(.class)가 나옵니다. 이 파일을 컴파일 타임이 아닌 런타임에(동적으로) 메모리로 올려서 실행하는 부분이 Class Loader 입니다.

#### Execution Engine
Class Loader에 의해 메모리에 로딩된 후에는 Execution Engine이 주도합니다.. 바이파일을 해석을 주로 합니다.

※ 실행 방식의 2가지

1. 인터프리터

2. JIT(Just In Time)

#### Runtime Data Area
Execution Engine에게 해석된 프로그램은 Runtime Data Area에 배치되어 돌아갑니다.. JVM의 메모리 영역입니다.. JVM은 필요에 따라 GC나 쓰레드 동기화등 관리를 해주기도 합니다..


####  Garbage Collector

메모리 관리를 GC가 해줍니다. 즉, 비즈니스 로직에만 집중할 수 있게 해줍니다.. 예를 들어 C언어는 개발자가 malloc하면 꼭 free를 해주어야 했습니다.. 그러나 GC는 이것을 똑똑하게 자동으로 처리해줍니다.

# JRE 와 JDK의 차이점

### JRE
JRE는 자바 실행환경(Java Runtime Environment)의 약자입니다.

JRE는 JVM 이 자바 프로그램을 동작시킬 때 필요한 라이브러리 파일들과 기타 파일들을 가지고 있습니다.. JRE는 JVM의 실행환경을 구현했다고 할 수 있습니다.

### JDK
JDK는 자바 개발도구(Java Development Kit)의 약자입니다..

JDK는 JRE + 개발을 위해 필요한 도구(javac, java등)들을 포함합니다.









